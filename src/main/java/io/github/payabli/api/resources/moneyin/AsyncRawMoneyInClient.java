/**
 * This file was auto-generated by Fern from our API Definition.
 */
package io.github.payabli.api.resources.moneyin;

import com.fasterxml.jackson.core.JsonProcessingException;
import io.github.payabli.api.core.ClientOptions;
import io.github.payabli.api.core.MediaTypes;
import io.github.payabli.api.core.ObjectMappers;
import io.github.payabli.api.core.PayabliApiApiException;
import io.github.payabli.api.core.PayabliApiException;
import io.github.payabli.api.core.PayabliApiHttpResponse;
import io.github.payabli.api.core.QueryStringMapper;
import io.github.payabli.api.core.RequestOptions;
import io.github.payabli.api.errors.BadRequestError;
import io.github.payabli.api.errors.InternalServerError;
import io.github.payabli.api.errors.ServiceUnavailableError;
import io.github.payabli.api.errors.UnauthorizedError;
import io.github.payabli.api.resources.moneyin.requests.RequestCredit;
import io.github.payabli.api.resources.moneyin.requests.RequestPayment;
import io.github.payabli.api.resources.moneyin.requests.RequestPaymentAuthorize;
import io.github.payabli.api.resources.moneyin.requests.RequestPaymentAuthorizeV2;
import io.github.payabli.api.resources.moneyin.requests.RequestPaymentV2;
import io.github.payabli.api.resources.moneyin.requests.RequestPaymentValidate;
import io.github.payabli.api.resources.moneyin.requests.RequestRefund;
import io.github.payabli.api.resources.moneyin.requests.SendReceipt2TransRequest;
import io.github.payabli.api.resources.moneyin.types.AuthResponse;
import io.github.payabli.api.resources.moneyin.types.CaptureRequest;
import io.github.payabli.api.resources.moneyin.types.CaptureResponse;
import io.github.payabli.api.resources.moneyin.types.PayabliApiResponseGetPaid;
import io.github.payabli.api.resources.moneyin.types.ReceiptResponse;
import io.github.payabli.api.resources.moneyin.types.RefundResponse;
import io.github.payabli.api.resources.moneyin.types.RefundWithInstructionsResponse;
import io.github.payabli.api.resources.moneyin.types.ReverseResponse;
import io.github.payabli.api.resources.moneyin.types.TransRequestBody;
import io.github.payabli.api.resources.moneyin.types.ValidateResponse;
import io.github.payabli.api.resources.moneyin.types.VoidResponse;
import io.github.payabli.api.resources.v2moneyintypes.errors.BadRequestAuthResponseErrorV2;
import io.github.payabli.api.resources.v2moneyintypes.errors.BadRequestCaptureResponseErrorV2;
import io.github.payabli.api.resources.v2moneyintypes.errors.BadRequestRefundResponseErrorV2;
import io.github.payabli.api.resources.v2moneyintypes.errors.BadRequestVoidResponseErrorV2;
import io.github.payabli.api.resources.v2moneyintypes.errors.DeclinedAuthResponseErrorV2;
import io.github.payabli.api.resources.v2moneyintypes.errors.DeclinedCaptureResponseErrorV2;
import io.github.payabli.api.resources.v2moneyintypes.errors.DeclinedRefundResponseErrorV2;
import io.github.payabli.api.resources.v2moneyintypes.errors.DeclinedVoidResponseErrorV2;
import io.github.payabli.api.resources.v2moneyintypes.errors.InternalServerResponseErrorV2;
import io.github.payabli.api.resources.v2moneyintypes.types.V2BadRequestError;
import io.github.payabli.api.resources.v2moneyintypes.types.V2DeclinedTransactionResponseWrapper;
import io.github.payabli.api.resources.v2moneyintypes.types.V2InternalServerError;
import io.github.payabli.api.resources.v2moneyintypes.types.V2TransactionResponseWrapper;
import io.github.payabli.api.types.PayabliApiResponse;
import io.github.payabli.api.types.PayabliApiResponse0;
import io.github.payabli.api.types.TransactionQueryRecordsCustomer;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawMoneyInClient {
    protected final ClientOptions clientOptions;

    public AsyncRawMoneyInClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until <a href="/developers/api-reference/moneyin/capture-an-authorized-transaction">captured</a>.
     * Only card transactions can be authorized. This endpoint can't be used for ACH transactions.
     * &lt;Tip&gt;
     * Consider migrating to the <a href="/developers/api-reference/moneyinV2/authorize-a-transaction">v2 Authorize endpoint</a> to take advantage of unified response codes and improved response consistency.
     * &lt;/Tip&gt;
     */
    public CompletableFuture<PayabliApiHttpResponse<AuthResponse>> authorize(TransRequestBody body) {
        return authorize(RequestPaymentAuthorize.builder().body(body).build());
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until <a href="/developers/api-reference/moneyin/capture-an-authorized-transaction">captured</a>.
     * Only card transactions can be authorized. This endpoint can't be used for ACH transactions.
     * &lt;Tip&gt;
     * Consider migrating to the <a href="/developers/api-reference/moneyinV2/authorize-a-transaction">v2 Authorize endpoint</a> to take advantage of unified response codes and improved response consistency.
     * &lt;/Tip&gt;
     */
    public CompletableFuture<PayabliApiHttpResponse<AuthResponse>> authorize(
            TransRequestBody body, RequestOptions requestOptions) {
        return authorize(RequestPaymentAuthorize.builder().body(body).build(), requestOptions);
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until <a href="/developers/api-reference/moneyin/capture-an-authorized-transaction">captured</a>.
     * Only card transactions can be authorized. This endpoint can't be used for ACH transactions.
     * &lt;Tip&gt;
     * Consider migrating to the <a href="/developers/api-reference/moneyinV2/authorize-a-transaction">v2 Authorize endpoint</a> to take advantage of unified response codes and improved response consistency.
     * &lt;/Tip&gt;
     */
    public CompletableFuture<PayabliApiHttpResponse<AuthResponse>> authorize(RequestPaymentAuthorize request) {
        return authorize(request, null);
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until <a href="/developers/api-reference/moneyin/capture-an-authorized-transaction">captured</a>.
     * Only card transactions can be authorized. This endpoint can't be used for ACH transactions.
     * &lt;Tip&gt;
     * Consider migrating to the <a href="/developers/api-reference/moneyinV2/authorize-a-transaction">v2 Authorize endpoint</a> to take advantage of unified response codes and improved response consistency.
     * &lt;/Tip&gt;
     */
    public CompletableFuture<PayabliApiHttpResponse<AuthResponse>> authorize(
            RequestPaymentAuthorize request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/authorize");
        if (request.getForceCustomerCreation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "forceCustomerCreation",
                    request.getForceCustomerCreation().get(),
                    false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        if (request.getIdempotencyKey().isPresent()) {
            _requestBuilder.addHeader(
                    "idempotencyKey", request.getIdempotencyKey().get());
        }
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<AuthResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, AuthResponse.class), response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * <p>&lt;Warning&gt;
     *   This endpoint is deprecated and will be sunset on November 24, 2025. Migrate to [POST `/capture/{transId}`](/developers/api-reference/moneyin/capture-an-authorized-transaction)`.
     * &lt;/Warning&gt;</p>
     * Capture an <a href="/developers/api-reference/moneyin/authorize-a-transaction">authorized
     * transaction</a> to complete the transaction and move funds from the customer to merchant account.
     */
    public CompletableFuture<PayabliApiHttpResponse<CaptureResponse>> capture(String transId, double amount) {
        return capture(transId, amount, null);
    }

    /**
     * <p>&lt;Warning&gt;
     *   This endpoint is deprecated and will be sunset on November 24, 2025. Migrate to [POST `/capture/{transId}`](/developers/api-reference/moneyin/capture-an-authorized-transaction)`.
     * &lt;/Warning&gt;</p>
     * Capture an <a href="/developers/api-reference/moneyin/authorize-a-transaction">authorized
     * transaction</a> to complete the transaction and move funds from the customer to merchant account.
     */
    public CompletableFuture<PayabliApiHttpResponse<CaptureResponse>> capture(
            String transId, double amount, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/capture")
                .addPathSegment(transId)
                .addPathSegment(Double.toString(amount));
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<CaptureResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, CaptureResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Capture an <a href="/developers/api-reference/moneyin/authorize-a-transaction">authorized transaction</a> to complete the transaction and move funds from the customer to merchant account.
     * <p>You can use this endpoint to capture both full and partial amounts of the original authorized transaction. See <a href="/developers/developer-guides/pay-in-auth-and-capture">Capture an authorized transaction</a> for more information about this endpoint.</p>
     * <p>&lt;Tip&gt;
     * Consider migrating to the [v2 Capture endpoint](/developers/api-reference/moneyinV2/capture-an-authorized-transaction) to take advantage of unified response codes and improved response consistency.
     * &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<CaptureResponse>> captureAuth(
            String transId, CaptureRequest request) {
        return captureAuth(transId, request, null);
    }

    /**
     * Capture an <a href="/developers/api-reference/moneyin/authorize-a-transaction">authorized transaction</a> to complete the transaction and move funds from the customer to merchant account.
     * <p>You can use this endpoint to capture both full and partial amounts of the original authorized transaction. See <a href="/developers/developer-guides/pay-in-auth-and-capture">Capture an authorized transaction</a> for more information about this endpoint.</p>
     * <p>&lt;Tip&gt;
     * Consider migrating to the [v2 Capture endpoint](/developers/api-reference/moneyinV2/capture-an-authorized-transaction) to take advantage of unified response codes and improved response consistency.
     * &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<CaptureResponse>> captureAuth(
            String transId, CaptureRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/capture")
                .addPathSegment(transId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PayabliApiException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<CaptureResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, CaptureResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Make a temporary microdeposit in a customer account to verify the customer's ownership and access to the target account. Reverse the microdeposit with <code>reverseCredit</code>.
     * <p>This feature must be enabled by Payabli on a per-merchant basis. Contact support for help.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<PayabliApiResponse0>> credit(RequestCredit request) {
        return credit(request, null);
    }

    /**
     * Make a temporary microdeposit in a customer account to verify the customer's ownership and access to the target account. Reverse the microdeposit with <code>reverseCredit</code>.
     * <p>This feature must be enabled by Payabli on a per-merchant basis. Contact support for help.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<PayabliApiResponse0>> credit(
            RequestCredit request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/makecredit");
        if (request.getForceCustomerCreation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "forceCustomerCreation",
                    request.getForceCustomerCreation().get(),
                    false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        if (request.getIdempotencyKey().isPresent()) {
            _requestBuilder.addHeader(
                    "idempotencyKey", request.getIdempotencyKey().get());
        }
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<PayabliApiResponse0>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, PayabliApiResponse0.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Retrieve a processed transaction's details.
     */
    public CompletableFuture<PayabliApiHttpResponse<TransactionQueryRecordsCustomer>> details(String transId) {
        return details(transId, null);
    }

    /**
     * Retrieve a processed transaction's details.
     */
    public CompletableFuture<PayabliApiHttpResponse<TransactionQueryRecordsCustomer>> details(
            String transId, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/details")
                .addPathSegment(transId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<TransactionQueryRecordsCustomer>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, TransactionQueryRecordsCustomer.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step.
     * <p>  &lt;Tip&gt;
     *   Consider migrating to the [v2 Make a transaction endpoint](/developers/api-reference/moneyinV2/make-a-transaction) to take advantage of unified response codes and improved response consistency.
     *   &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<PayabliApiResponseGetPaid>> getpaid(TransRequestBody body) {
        return getpaid(RequestPayment.builder().body(body).build());
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step.
     * <p>  &lt;Tip&gt;
     *   Consider migrating to the [v2 Make a transaction endpoint](/developers/api-reference/moneyinV2/make-a-transaction) to take advantage of unified response codes and improved response consistency.
     *   &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<PayabliApiResponseGetPaid>> getpaid(
            TransRequestBody body, RequestOptions requestOptions) {
        return getpaid(RequestPayment.builder().body(body).build(), requestOptions);
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step.
     * <p>  &lt;Tip&gt;
     *   Consider migrating to the [v2 Make a transaction endpoint](/developers/api-reference/moneyinV2/make-a-transaction) to take advantage of unified response codes and improved response consistency.
     *   &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<PayabliApiResponseGetPaid>> getpaid(RequestPayment request) {
        return getpaid(request, null);
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step.
     * <p>  &lt;Tip&gt;
     *   Consider migrating to the [v2 Make a transaction endpoint](/developers/api-reference/moneyinV2/make-a-transaction) to take advantage of unified response codes and improved response consistency.
     *   &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<PayabliApiResponseGetPaid>> getpaid(
            RequestPayment request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/getpaid");
        if (request.getAchValidation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "achValidation", request.getAchValidation().get(), false);
        }
        if (request.getForceCustomerCreation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "forceCustomerCreation",
                    request.getForceCustomerCreation().get(),
                    false);
        }
        if (request.getIncludeDetails().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "includeDetails", request.getIncludeDetails().get(), false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        if (request.getIdempotencyKey().isPresent()) {
            _requestBuilder.addHeader(
                    "idempotencyKey", request.getIdempotencyKey().get());
        }
        if (request.getValidationCode().isPresent()) {
            _requestBuilder.addHeader(
                    "validationCode", request.getValidationCode().get());
        }
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<PayabliApiResponseGetPaid>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, PayabliApiResponseGetPaid.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * A reversal either refunds or voids a transaction independent of the transaction's settlement status. Send a reversal request for a transaction, and Payabli automatically determines whether it's a refund or void. You don't need to know whether the transaction is settled or not.
     */
    public CompletableFuture<PayabliApiHttpResponse<ReverseResponse>> reverse(String transId, double amount) {
        return reverse(transId, amount, null);
    }

    /**
     * A reversal either refunds or voids a transaction independent of the transaction's settlement status. Send a reversal request for a transaction, and Payabli automatically determines whether it's a refund or void. You don't need to know whether the transaction is settled or not.
     */
    public CompletableFuture<PayabliApiHttpResponse<ReverseResponse>> reverse(
            String transId, double amount, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/reverse")
                .addPathSegment(transId)
                .addPathSegment(Double.toString(amount));
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<ReverseResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ReverseResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Refund a transaction that has settled and send money back to the account holder. If a transaction hasn't been settled, void it instead.
     * <p>  &lt;Tip&gt;
     *   Consider migrating to the [v2 Refund endpoint](/developers/api-reference/moneyinV2/refund-a-settled-transaction) to take advantage of unified response codes and improved response consistency.
     *   &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<RefundResponse>> refund(String transId, double amount) {
        return refund(transId, amount, null);
    }

    /**
     * Refund a transaction that has settled and send money back to the account holder. If a transaction hasn't been settled, void it instead.
     * <p>  &lt;Tip&gt;
     *   Consider migrating to the [v2 Refund endpoint](/developers/api-reference/moneyinV2/refund-a-settled-transaction) to take advantage of unified response codes and improved response consistency.
     *   &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<RefundResponse>> refund(
            String transId, double amount, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/refund")
                .addPathSegment(transId)
                .addPathSegment(Double.toString(amount));
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<RefundResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, RefundResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Refunds a settled transaction with split instructions.
     */
    public CompletableFuture<PayabliApiHttpResponse<RefundWithInstructionsResponse>> refundWithInstructions(
            String transId) {
        return refundWithInstructions(transId, RequestRefund.builder().build());
    }

    /**
     * Refunds a settled transaction with split instructions.
     */
    public CompletableFuture<PayabliApiHttpResponse<RefundWithInstructionsResponse>> refundWithInstructions(
            String transId, RequestOptions requestOptions) {
        return refundWithInstructions(transId, RequestRefund.builder().build(), requestOptions);
    }

    /**
     * Refunds a settled transaction with split instructions.
     */
    public CompletableFuture<PayabliApiHttpResponse<RefundWithInstructionsResponse>> refundWithInstructions(
            String transId, RequestRefund request) {
        return refundWithInstructions(transId, request, null);
    }

    /**
     * Refunds a settled transaction with split instructions.
     */
    public CompletableFuture<PayabliApiHttpResponse<RefundWithInstructionsResponse>> refundWithInstructions(
            String transId, RequestRefund request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/refund")
                .addPathSegment(transId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        if (request.getIdempotencyKey().isPresent()) {
            _requestBuilder.addHeader(
                    "idempotencyKey", request.getIdempotencyKey().get());
        }
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<RefundWithInstructionsResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, RefundWithInstructionsResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Reverse microdeposits that are used to verify customer account ownership and access. The <code>transId</code> value is returned in the success response for the original credit transaction made with <code>api/MoneyIn/makecredit</code>.
     */
    public CompletableFuture<PayabliApiHttpResponse<PayabliApiResponse>> reverseCredit(String transId) {
        return reverseCredit(transId, null);
    }

    /**
     * Reverse microdeposits that are used to verify customer account ownership and access. The <code>transId</code> value is returned in the success response for the original credit transaction made with <code>api/MoneyIn/makecredit</code>.
     */
    public CompletableFuture<PayabliApiHttpResponse<PayabliApiResponse>> reverseCredit(
            String transId, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/reverseCredit")
                .addPathSegment(transId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<PayabliApiResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, PayabliApiResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Send a payment receipt for a transaction.
     */
    public CompletableFuture<PayabliApiHttpResponse<ReceiptResponse>> sendReceipt2Trans(String transId) {
        return sendReceipt2Trans(transId, SendReceipt2TransRequest.builder().build());
    }

    /**
     * Send a payment receipt for a transaction.
     */
    public CompletableFuture<PayabliApiHttpResponse<ReceiptResponse>> sendReceipt2Trans(
            String transId, RequestOptions requestOptions) {
        return sendReceipt2Trans(transId, SendReceipt2TransRequest.builder().build(), requestOptions);
    }

    /**
     * Send a payment receipt for a transaction.
     */
    public CompletableFuture<PayabliApiHttpResponse<ReceiptResponse>> sendReceipt2Trans(
            String transId, SendReceipt2TransRequest request) {
        return sendReceipt2Trans(transId, request, null);
    }

    /**
     * Send a payment receipt for a transaction.
     */
    public CompletableFuture<PayabliApiHttpResponse<ReceiptResponse>> sendReceipt2Trans(
            String transId, SendReceipt2TransRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/sendreceipt")
                .addPathSegment(transId);
        if (request.getEmail().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "email", request.getEmail().get(), false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<ReceiptResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ReceiptResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Validates a card number without running a transaction or authorizing a charge.
     */
    public CompletableFuture<PayabliApiHttpResponse<ValidateResponse>> validate(RequestPaymentValidate request) {
        return validate(request, null);
    }

    /**
     * Validates a card number without running a transaction or authorizing a charge.
     */
    public CompletableFuture<PayabliApiHttpResponse<ValidateResponse>> validate(
            RequestPaymentValidate request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/validate");
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        if (request.getIdempotencyKey().isPresent()) {
            _requestBuilder.addHeader(
                    "idempotencyKey", request.getIdempotencyKey().get());
        }
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<ValidateResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ValidateResponse.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Cancel a transaction that hasn't been settled yet. Voiding non-captured authorizations prevents future captures. If a transaction has been settled, refund it instead.
     * <p>  &lt;Tip&gt;
     *   Consider migrating to the [v2 Void endpoint](/developers/api-reference/moneyinV2/void-a-transaction) to take advantage of unified response codes and improved response consistency.
     *   &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<VoidResponse>> void_(String transId) {
        return void_(transId, null);
    }

    /**
     * Cancel a transaction that hasn't been settled yet. Voiding non-captured authorizations prevents future captures. If a transaction has been settled, refund it instead.
     * <p>  &lt;Tip&gt;
     *   Consider migrating to the [v2 Void endpoint](/developers/api-reference/moneyinV2/void-a-transaction) to take advantage of unified response codes and improved response consistency.
     *   &lt;/Tip&gt;</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<VoidResponse>> void_(
            String transId, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("MoneyIn/void")
                .addPathSegment(transId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<VoidResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, VoidResponse.class), response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 503:
                                future.completeExceptionally(new ServiceUnavailableError(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, PayabliApiResponse.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step. This is the v2 version of the <code>api/MoneyIn/getpaid</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> getpaidv2(TransRequestBody body) {
        return getpaidv2(RequestPaymentV2.builder().body(body).build());
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step. This is the v2 version of the <code>api/MoneyIn/getpaid</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> getpaidv2(
            TransRequestBody body, RequestOptions requestOptions) {
        return getpaidv2(RequestPaymentV2.builder().body(body).build(), requestOptions);
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step. This is the v2 version of the <code>api/MoneyIn/getpaid</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> getpaidv2(RequestPaymentV2 request) {
        return getpaidv2(request, null);
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step. This is the v2 version of the <code>api/MoneyIn/getpaid</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> getpaidv2(
            RequestPaymentV2 request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/MoneyIn/getpaid");
        if (request.getAchValidation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "achValidation", request.getAchValidation().get(), false);
        }
        if (request.getForceCustomerCreation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "forceCustomerCreation",
                    request.getForceCustomerCreation().get(),
                    false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        if (request.getIdempotencyKey().isPresent()) {
            _requestBuilder.addHeader(
                    "idempotencyKey", request.getIdempotencyKey().get());
        }
        if (request.getValidationCode().isPresent()) {
            _requestBuilder.addHeader(
                    "validationCode", request.getValidationCode().get());
        }
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, V2TransactionResponseWrapper.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestAuthResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2BadRequestError.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new DeclinedAuthResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2DeclinedTransactionResponseWrapper.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2InternalServerError.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until captured. This is the v2 version of the <code>api/MoneyIn/authorize</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     * <p><strong>Note</strong>: Only card transactions can be authorized. This endpoint can't be used for ACH transactions.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> authorizev2(TransRequestBody body) {
        return authorizev2(RequestPaymentAuthorizeV2.builder().body(body).build());
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until captured. This is the v2 version of the <code>api/MoneyIn/authorize</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     * <p><strong>Note</strong>: Only card transactions can be authorized. This endpoint can't be used for ACH transactions.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> authorizev2(
            TransRequestBody body, RequestOptions requestOptions) {
        return authorizev2(RequestPaymentAuthorizeV2.builder().body(body).build(), requestOptions);
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until captured. This is the v2 version of the <code>api/MoneyIn/authorize</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     * <p><strong>Note</strong>: Only card transactions can be authorized. This endpoint can't be used for ACH transactions.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> authorizev2(
            RequestPaymentAuthorizeV2 request) {
        return authorizev2(request, null);
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until captured. This is the v2 version of the <code>api/MoneyIn/authorize</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     * <p><strong>Note</strong>: Only card transactions can be authorized. This endpoint can't be used for ACH transactions.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> authorizev2(
            RequestPaymentAuthorizeV2 request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/MoneyIn/authorize");
        if (request.getForceCustomerCreation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "forceCustomerCreation",
                    request.getForceCustomerCreation().get(),
                    false);
        }
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        if (request.getIdempotencyKey().isPresent()) {
            _requestBuilder.addHeader(
                    "idempotencyKey", request.getIdempotencyKey().get());
        }
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, V2TransactionResponseWrapper.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestAuthResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2BadRequestError.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new DeclinedAuthResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2DeclinedTransactionResponseWrapper.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2InternalServerError.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Capture an authorized transaction to complete the transaction and move funds from the customer to merchant account. This is the v2 version of the <code>api/MoneyIn/capture/{transId}</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> capturev2(
            String transId, CaptureRequest request) {
        return capturev2(transId, request, null);
    }

    /**
     * Capture an authorized transaction to complete the transaction and move funds from the customer to merchant account. This is the v2 version of the <code>api/MoneyIn/capture/{transId}</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> capturev2(
            String transId, CaptureRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/MoneyIn/capture")
                .addPathSegment(transId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PayabliApiException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, V2TransactionResponseWrapper.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestCaptureResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2BadRequestError.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new DeclinedCaptureResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2DeclinedTransactionResponseWrapper.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2InternalServerError.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Give a full refund for a transaction that has settled and send money back to the account holder. To perform a partial refund, see <a href="developers/api-reference/moneyinV2/partial-refund-a-settled-transaction">Partially refund a transaction</a>.
     * <p>This is the v2 version of the refund endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> refundv2(String transId) {
        return refundv2(transId, null);
    }

    /**
     * Give a full refund for a transaction that has settled and send money back to the account holder. To perform a partial refund, see <a href="developers/api-reference/moneyinV2/partial-refund-a-settled-transaction">Partially refund a transaction</a>.
     * <p>This is the v2 version of the refund endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> refundv2(
            String transId, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/MoneyIn/refund")
                .addPathSegment(transId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, V2TransactionResponseWrapper.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestRefundResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2BadRequestError.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new DeclinedRefundResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2DeclinedTransactionResponseWrapper.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2InternalServerError.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Refund a transaction that has settled and send money back to the account holder. If <code>amount</code> is omitted or set to 0, performs a full refund. When a non-zero <code>amount</code> is provided, this endpoint performs a partial refund.
     * <p>This is the v2 version of the refund endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> refundv2Amount(
            String transId, double amount) {
        return refundv2Amount(transId, amount, null);
    }

    /**
     * Refund a transaction that has settled and send money back to the account holder. If <code>amount</code> is omitted or set to 0, performs a full refund. When a non-zero <code>amount</code> is provided, this endpoint performs a partial refund.
     * <p>This is the v2 version of the refund endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.</p>
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> refundv2Amount(
            String transId, double amount, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/MoneyIn/refund")
                .addPathSegment(transId)
                .addPathSegment(Double.toString(amount));
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, V2TransactionResponseWrapper.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestRefundResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2BadRequestError.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new DeclinedRefundResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2DeclinedTransactionResponseWrapper.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2InternalServerError.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Cancel a transaction that hasn't been settled yet. Voiding non-captured authorizations prevents future captures. This is the v2 version of the <code>api/MoneyIn/void/{transId}</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> voidv2(String transId) {
        return voidv2(transId, null);
    }

    /**
     * Cancel a transaction that hasn't been settled yet. Voiding non-captured authorizations prevents future captures. This is the v2 version of the <code>api/MoneyIn/void/{transId}</code> endpoint, and returns the unified response format. See <a href="/guides/pay-in-unified-response-codes-reference">Pay In unified response codes reference</a> for more information.
     */
    public CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> voidv2(
            String transId, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v2/MoneyIn/void")
                .addPathSegment(transId);
        if (requestOptions != null) {
            requestOptions.getQueryParameters().forEach((_key, _value) -> {
                httpUrl.addQueryParameter(_key, _value);
            });
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl.build())
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PayabliApiHttpResponse<V2TransactionResponseWrapper>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    if (response.isSuccessful()) {
                        future.complete(new PayabliApiHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBodyString, V2TransactionResponseWrapper.class),
                                response));
                        return;
                    }
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestVoidResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2BadRequestError.class),
                                        response));
                                return;
                            case 401:
                                future.completeExceptionally(new UnauthorizedError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 402:
                                future.completeExceptionally(new DeclinedVoidResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2DeclinedTransactionResponseWrapper.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerResponseErrorV2(
                                        ObjectMappers.JSON_MAPPER.readValue(
                                                responseBodyString, V2InternalServerError.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    Object errorBody = ObjectMappers.parseErrorBody(responseBodyString);
                    future.completeExceptionally(new PayabliApiApiException(
                            "Error with status code " + response.code(), response.code(), errorBody, response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PayabliApiException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}

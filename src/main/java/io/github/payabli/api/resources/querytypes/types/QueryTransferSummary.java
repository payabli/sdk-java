/**
 * This file was auto-generated by Fern from our API Definition.
 */
package io.github.payabli.api.resources.querytypes.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import io.github.payabli.api.core.Nullable;
import io.github.payabli.api.core.NullableNonemptyFilter;
import io.github.payabli.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = QueryTransferSummary.Builder.class)
public final class QueryTransferSummary {
    private final Optional<Double> achReturns;

    private final Optional<Double> adjustments;

    private final Optional<Double> billingFees;

    private final Optional<Double> chargebacks;

    private final Optional<Double> grossTransferAmount;

    private final Optional<Double> releaseAmount;

    private final Optional<Double> thirdPartyPaid;

    private final Optional<Double> totalNetAmountTransfer;

    private final Optional<Double> splitAmount;

    private final Optional<Double> serviceFees;

    private final Optional<Double> netBatchAmount;

    private final Optional<Double> transferAmount;

    private final Optional<Double> refunds;

    private final Optional<Double> heldAmount;

    private final Optional<Integer> totalRecords;

    private final Optional<Double> totalAmount;

    private final Optional<Double> totalNetAmount;

    private final Optional<Integer> totalPages;

    private final Optional<Integer> pageSize;

    private final Optional<String> pageidentifier;

    private final Map<String, Object> additionalProperties;

    private QueryTransferSummary(
            Optional<Double> achReturns,
            Optional<Double> adjustments,
            Optional<Double> billingFees,
            Optional<Double> chargebacks,
            Optional<Double> grossTransferAmount,
            Optional<Double> releaseAmount,
            Optional<Double> thirdPartyPaid,
            Optional<Double> totalNetAmountTransfer,
            Optional<Double> splitAmount,
            Optional<Double> serviceFees,
            Optional<Double> netBatchAmount,
            Optional<Double> transferAmount,
            Optional<Double> refunds,
            Optional<Double> heldAmount,
            Optional<Integer> totalRecords,
            Optional<Double> totalAmount,
            Optional<Double> totalNetAmount,
            Optional<Integer> totalPages,
            Optional<Integer> pageSize,
            Optional<String> pageidentifier,
            Map<String, Object> additionalProperties) {
        this.achReturns = achReturns;
        this.adjustments = adjustments;
        this.billingFees = billingFees;
        this.chargebacks = chargebacks;
        this.grossTransferAmount = grossTransferAmount;
        this.releaseAmount = releaseAmount;
        this.thirdPartyPaid = thirdPartyPaid;
        this.totalNetAmountTransfer = totalNetAmountTransfer;
        this.splitAmount = splitAmount;
        this.serviceFees = serviceFees;
        this.netBatchAmount = netBatchAmount;
        this.transferAmount = transferAmount;
        this.refunds = refunds;
        this.heldAmount = heldAmount;
        this.totalRecords = totalRecords;
        this.totalAmount = totalAmount;
        this.totalNetAmount = totalNetAmount;
        this.totalPages = totalPages;
        this.pageSize = pageSize;
        this.pageidentifier = pageidentifier;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return ACH returns deducted from the batch.
     */
    @JsonIgnore
    public Optional<Double> getAchReturns() {
        if (achReturns == null) {
            return Optional.empty();
        }
        return achReturns;
    }

    /**
     * @return Corrections applied to Billing &amp; Fees charges.
     */
    @JsonIgnore
    public Optional<Double> getAdjustments() {
        if (adjustments == null) {
            return Optional.empty();
        }
        return adjustments;
    }

    /**
     * @return Charges applied for transactions and services.
     */
    @JsonIgnore
    public Optional<Double> getBillingFees() {
        if (billingFees == null) {
            return Optional.empty();
        }
        return billingFees;
    }

    /**
     * @return Chargebacks deducted from batch.
     */
    @JsonIgnore
    public Optional<Double> getChargebacks() {
        if (chargebacks == null) {
            return Optional.empty();
        }
        return chargebacks;
    }

    /**
     * @return The gross batch amount before deductions.
     */
    @JsonIgnore
    public Optional<Double> getGrossTransferAmount() {
        if (grossTransferAmount == null) {
            return Optional.empty();
        }
        return grossTransferAmount;
    }

    /**
     * @return Previously held funds that have been released after a risk review.
     */
    @JsonIgnore
    public Optional<Double> getReleaseAmount() {
        if (releaseAmount == null) {
            return Optional.empty();
        }
        return releaseAmount;
    }

    /**
     * @return Payments captured in the batch cycle that are deposited separately. For example,  checks or cash payments recorded in the batch but not deposited via Payabli,  or card brands making a direct transfer in certain situations.
     */
    @JsonIgnore
    public Optional<Double> getThirdPartyPaid() {
        if (thirdPartyPaid == null) {
            return Optional.empty();
        }
        return thirdPartyPaid;
    }

    /**
     * @return The gross batch amount minus service fees.
     */
    @JsonIgnore
    public Optional<Double> getTotalNetAmountTransfer() {
        if (totalNetAmountTransfer == null) {
            return Optional.empty();
        }
        return totalNetAmountTransfer;
    }

    /**
     * @return The sum of each splitFundingAmount of each record in the transfer.
     */
    @JsonIgnore
    public Optional<Double> getSplitAmount() {
        if (splitAmount == null) {
            return Optional.empty();
        }
        return splitAmount;
    }

    /**
     * @return Service fees are any pass-through fees charged to the customer at the time of payment.  These aren't transferred to the merchant when the batch is transferred and funded.
     */
    @JsonIgnore
    public Optional<Double> getServiceFees() {
        if (serviceFees == null) {
            return Optional.empty();
        }
        return serviceFees;
    }

    /**
     * @return The net batch amount is the gross batch amount minus any returns, refunds,
     * billing and fees items, chargebacks, adjustments, and third party payments.
     */
    @JsonIgnore
    public Optional<Double> getNetBatchAmount() {
        if (netBatchAmount == null) {
            return Optional.empty();
        }
        return netBatchAmount;
    }

    /**
     * @return The transfer amount is the net batch amount plus or minus any returns, refunds,  billing and fees items, chargebacks, adjustments, and third party payments.  This is the amount from the batch that is transferred to the merchant bank account.
     */
    @JsonIgnore
    public Optional<Double> getTransferAmount() {
        if (transferAmount == null) {
            return Optional.empty();
        }
        return transferAmount;
    }

    /**
     * @return Refunds deducted from batch.
     */
    @JsonIgnore
    public Optional<Double> getRefunds() {
        if (refunds == null) {
            return Optional.empty();
        }
        return refunds;
    }

    /**
     * @return Funds being held for fraud or risk concerns.
     */
    @JsonIgnore
    public Optional<Double> getHeldAmount() {
        if (heldAmount == null) {
            return Optional.empty();
        }
        return heldAmount;
    }

    /**
     * @return Number of records in the response.
     */
    @JsonIgnore
    public Optional<Integer> getTotalRecords() {
        if (totalRecords == null) {
            return Optional.empty();
        }
        return totalRecords;
    }

    /**
     * @return The total sum of the transfers in the response.
     */
    @JsonIgnore
    public Optional<Double> getTotalAmount() {
        if (totalAmount == null) {
            return Optional.empty();
        }
        return totalAmount;
    }

    /**
     * @return The total sum of the transfers in the response.
     */
    @JsonIgnore
    public Optional<Double> getTotalNetAmount() {
        if (totalNetAmount == null) {
            return Optional.empty();
        }
        return totalNetAmount;
    }

    /**
     * @return Number of pages in the response.
     */
    @JsonIgnore
    public Optional<Integer> getTotalPages() {
        if (totalPages == null) {
            return Optional.empty();
        }
        return totalPages;
    }

    /**
     * @return Number of records per page.
     */
    @JsonIgnore
    public Optional<Integer> getPageSize() {
        if (pageSize == null) {
            return Optional.empty();
        }
        return pageSize;
    }

    /**
     * @return Auxiliary validation used internally by payment pages and components.
     */
    @JsonIgnore
    public Optional<String> getPageidentifier() {
        if (pageidentifier == null) {
            return Optional.empty();
        }
        return pageidentifier;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("achReturns")
    private Optional<Double> _getAchReturns() {
        return achReturns;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("adjustments")
    private Optional<Double> _getAdjustments() {
        return adjustments;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("billingFees")
    private Optional<Double> _getBillingFees() {
        return billingFees;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("chargebacks")
    private Optional<Double> _getChargebacks() {
        return chargebacks;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("grossTransferAmount")
    private Optional<Double> _getGrossTransferAmount() {
        return grossTransferAmount;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("releaseAmount")
    private Optional<Double> _getReleaseAmount() {
        return releaseAmount;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("thirdPartyPaid")
    private Optional<Double> _getThirdPartyPaid() {
        return thirdPartyPaid;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("totalNetAmountTransfer")
    private Optional<Double> _getTotalNetAmountTransfer() {
        return totalNetAmountTransfer;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("splitAmount")
    private Optional<Double> _getSplitAmount() {
        return splitAmount;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("serviceFees")
    private Optional<Double> _getServiceFees() {
        return serviceFees;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("netBatchAmount")
    private Optional<Double> _getNetBatchAmount() {
        return netBatchAmount;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("transferAmount")
    private Optional<Double> _getTransferAmount() {
        return transferAmount;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("refunds")
    private Optional<Double> _getRefunds() {
        return refunds;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("heldAmount")
    private Optional<Double> _getHeldAmount() {
        return heldAmount;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("totalRecords")
    private Optional<Integer> _getTotalRecords() {
        return totalRecords;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("totalAmount")
    private Optional<Double> _getTotalAmount() {
        return totalAmount;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("totalNetAmount")
    private Optional<Double> _getTotalNetAmount() {
        return totalNetAmount;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("totalPages")
    private Optional<Integer> _getTotalPages() {
        return totalPages;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("pageSize")
    private Optional<Integer> _getPageSize() {
        return pageSize;
    }

    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = NullableNonemptyFilter.class)
    @JsonProperty("pageidentifier")
    private Optional<String> _getPageidentifier() {
        return pageidentifier;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof QueryTransferSummary && equalTo((QueryTransferSummary) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(QueryTransferSummary other) {
        return achReturns.equals(other.achReturns)
                && adjustments.equals(other.adjustments)
                && billingFees.equals(other.billingFees)
                && chargebacks.equals(other.chargebacks)
                && grossTransferAmount.equals(other.grossTransferAmount)
                && releaseAmount.equals(other.releaseAmount)
                && thirdPartyPaid.equals(other.thirdPartyPaid)
                && totalNetAmountTransfer.equals(other.totalNetAmountTransfer)
                && splitAmount.equals(other.splitAmount)
                && serviceFees.equals(other.serviceFees)
                && netBatchAmount.equals(other.netBatchAmount)
                && transferAmount.equals(other.transferAmount)
                && refunds.equals(other.refunds)
                && heldAmount.equals(other.heldAmount)
                && totalRecords.equals(other.totalRecords)
                && totalAmount.equals(other.totalAmount)
                && totalNetAmount.equals(other.totalNetAmount)
                && totalPages.equals(other.totalPages)
                && pageSize.equals(other.pageSize)
                && pageidentifier.equals(other.pageidentifier);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.achReturns,
                this.adjustments,
                this.billingFees,
                this.chargebacks,
                this.grossTransferAmount,
                this.releaseAmount,
                this.thirdPartyPaid,
                this.totalNetAmountTransfer,
                this.splitAmount,
                this.serviceFees,
                this.netBatchAmount,
                this.transferAmount,
                this.refunds,
                this.heldAmount,
                this.totalRecords,
                this.totalAmount,
                this.totalNetAmount,
                this.totalPages,
                this.pageSize,
                this.pageidentifier);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Double> achReturns = Optional.empty();

        private Optional<Double> adjustments = Optional.empty();

        private Optional<Double> billingFees = Optional.empty();

        private Optional<Double> chargebacks = Optional.empty();

        private Optional<Double> grossTransferAmount = Optional.empty();

        private Optional<Double> releaseAmount = Optional.empty();

        private Optional<Double> thirdPartyPaid = Optional.empty();

        private Optional<Double> totalNetAmountTransfer = Optional.empty();

        private Optional<Double> splitAmount = Optional.empty();

        private Optional<Double> serviceFees = Optional.empty();

        private Optional<Double> netBatchAmount = Optional.empty();

        private Optional<Double> transferAmount = Optional.empty();

        private Optional<Double> refunds = Optional.empty();

        private Optional<Double> heldAmount = Optional.empty();

        private Optional<Integer> totalRecords = Optional.empty();

        private Optional<Double> totalAmount = Optional.empty();

        private Optional<Double> totalNetAmount = Optional.empty();

        private Optional<Integer> totalPages = Optional.empty();

        private Optional<Integer> pageSize = Optional.empty();

        private Optional<String> pageidentifier = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(QueryTransferSummary other) {
            achReturns(other.getAchReturns());
            adjustments(other.getAdjustments());
            billingFees(other.getBillingFees());
            chargebacks(other.getChargebacks());
            grossTransferAmount(other.getGrossTransferAmount());
            releaseAmount(other.getReleaseAmount());
            thirdPartyPaid(other.getThirdPartyPaid());
            totalNetAmountTransfer(other.getTotalNetAmountTransfer());
            splitAmount(other.getSplitAmount());
            serviceFees(other.getServiceFees());
            netBatchAmount(other.getNetBatchAmount());
            transferAmount(other.getTransferAmount());
            refunds(other.getRefunds());
            heldAmount(other.getHeldAmount());
            totalRecords(other.getTotalRecords());
            totalAmount(other.getTotalAmount());
            totalNetAmount(other.getTotalNetAmount());
            totalPages(other.getTotalPages());
            pageSize(other.getPageSize());
            pageidentifier(other.getPageidentifier());
            return this;
        }

        /**
         * <p>ACH returns deducted from the batch.</p>
         */
        @JsonSetter(value = "achReturns", nulls = Nulls.SKIP)
        public Builder achReturns(Optional<Double> achReturns) {
            this.achReturns = achReturns;
            return this;
        }

        public Builder achReturns(Double achReturns) {
            this.achReturns = Optional.ofNullable(achReturns);
            return this;
        }

        public Builder achReturns(Nullable<Double> achReturns) {
            if (achReturns.isNull()) {
                this.achReturns = null;
            } else if (achReturns.isEmpty()) {
                this.achReturns = Optional.empty();
            } else {
                this.achReturns = Optional.of(achReturns.get());
            }
            return this;
        }

        /**
         * <p>Corrections applied to Billing &amp; Fees charges.</p>
         */
        @JsonSetter(value = "adjustments", nulls = Nulls.SKIP)
        public Builder adjustments(Optional<Double> adjustments) {
            this.adjustments = adjustments;
            return this;
        }

        public Builder adjustments(Double adjustments) {
            this.adjustments = Optional.ofNullable(adjustments);
            return this;
        }

        public Builder adjustments(Nullable<Double> adjustments) {
            if (adjustments.isNull()) {
                this.adjustments = null;
            } else if (adjustments.isEmpty()) {
                this.adjustments = Optional.empty();
            } else {
                this.adjustments = Optional.of(adjustments.get());
            }
            return this;
        }

        /**
         * <p>Charges applied for transactions and services.</p>
         */
        @JsonSetter(value = "billingFees", nulls = Nulls.SKIP)
        public Builder billingFees(Optional<Double> billingFees) {
            this.billingFees = billingFees;
            return this;
        }

        public Builder billingFees(Double billingFees) {
            this.billingFees = Optional.ofNullable(billingFees);
            return this;
        }

        public Builder billingFees(Nullable<Double> billingFees) {
            if (billingFees.isNull()) {
                this.billingFees = null;
            } else if (billingFees.isEmpty()) {
                this.billingFees = Optional.empty();
            } else {
                this.billingFees = Optional.of(billingFees.get());
            }
            return this;
        }

        /**
         * <p>Chargebacks deducted from batch.</p>
         */
        @JsonSetter(value = "chargebacks", nulls = Nulls.SKIP)
        public Builder chargebacks(Optional<Double> chargebacks) {
            this.chargebacks = chargebacks;
            return this;
        }

        public Builder chargebacks(Double chargebacks) {
            this.chargebacks = Optional.ofNullable(chargebacks);
            return this;
        }

        public Builder chargebacks(Nullable<Double> chargebacks) {
            if (chargebacks.isNull()) {
                this.chargebacks = null;
            } else if (chargebacks.isEmpty()) {
                this.chargebacks = Optional.empty();
            } else {
                this.chargebacks = Optional.of(chargebacks.get());
            }
            return this;
        }

        /**
         * <p>The gross batch amount before deductions.</p>
         */
        @JsonSetter(value = "grossTransferAmount", nulls = Nulls.SKIP)
        public Builder grossTransferAmount(Optional<Double> grossTransferAmount) {
            this.grossTransferAmount = grossTransferAmount;
            return this;
        }

        public Builder grossTransferAmount(Double grossTransferAmount) {
            this.grossTransferAmount = Optional.ofNullable(grossTransferAmount);
            return this;
        }

        public Builder grossTransferAmount(Nullable<Double> grossTransferAmount) {
            if (grossTransferAmount.isNull()) {
                this.grossTransferAmount = null;
            } else if (grossTransferAmount.isEmpty()) {
                this.grossTransferAmount = Optional.empty();
            } else {
                this.grossTransferAmount = Optional.of(grossTransferAmount.get());
            }
            return this;
        }

        /**
         * <p>Previously held funds that have been released after a risk review.</p>
         */
        @JsonSetter(value = "releaseAmount", nulls = Nulls.SKIP)
        public Builder releaseAmount(Optional<Double> releaseAmount) {
            this.releaseAmount = releaseAmount;
            return this;
        }

        public Builder releaseAmount(Double releaseAmount) {
            this.releaseAmount = Optional.ofNullable(releaseAmount);
            return this;
        }

        public Builder releaseAmount(Nullable<Double> releaseAmount) {
            if (releaseAmount.isNull()) {
                this.releaseAmount = null;
            } else if (releaseAmount.isEmpty()) {
                this.releaseAmount = Optional.empty();
            } else {
                this.releaseAmount = Optional.of(releaseAmount.get());
            }
            return this;
        }

        /**
         * <p>Payments captured in the batch cycle that are deposited separately. For example,  checks or cash payments recorded in the batch but not deposited via Payabli,  or card brands making a direct transfer in certain situations.</p>
         */
        @JsonSetter(value = "thirdPartyPaid", nulls = Nulls.SKIP)
        public Builder thirdPartyPaid(Optional<Double> thirdPartyPaid) {
            this.thirdPartyPaid = thirdPartyPaid;
            return this;
        }

        public Builder thirdPartyPaid(Double thirdPartyPaid) {
            this.thirdPartyPaid = Optional.ofNullable(thirdPartyPaid);
            return this;
        }

        public Builder thirdPartyPaid(Nullable<Double> thirdPartyPaid) {
            if (thirdPartyPaid.isNull()) {
                this.thirdPartyPaid = null;
            } else if (thirdPartyPaid.isEmpty()) {
                this.thirdPartyPaid = Optional.empty();
            } else {
                this.thirdPartyPaid = Optional.of(thirdPartyPaid.get());
            }
            return this;
        }

        /**
         * <p>The gross batch amount minus service fees.</p>
         */
        @JsonSetter(value = "totalNetAmountTransfer", nulls = Nulls.SKIP)
        public Builder totalNetAmountTransfer(Optional<Double> totalNetAmountTransfer) {
            this.totalNetAmountTransfer = totalNetAmountTransfer;
            return this;
        }

        public Builder totalNetAmountTransfer(Double totalNetAmountTransfer) {
            this.totalNetAmountTransfer = Optional.ofNullable(totalNetAmountTransfer);
            return this;
        }

        public Builder totalNetAmountTransfer(Nullable<Double> totalNetAmountTransfer) {
            if (totalNetAmountTransfer.isNull()) {
                this.totalNetAmountTransfer = null;
            } else if (totalNetAmountTransfer.isEmpty()) {
                this.totalNetAmountTransfer = Optional.empty();
            } else {
                this.totalNetAmountTransfer = Optional.of(totalNetAmountTransfer.get());
            }
            return this;
        }

        /**
         * <p>The sum of each splitFundingAmount of each record in the transfer.</p>
         */
        @JsonSetter(value = "splitAmount", nulls = Nulls.SKIP)
        public Builder splitAmount(Optional<Double> splitAmount) {
            this.splitAmount = splitAmount;
            return this;
        }

        public Builder splitAmount(Double splitAmount) {
            this.splitAmount = Optional.ofNullable(splitAmount);
            return this;
        }

        public Builder splitAmount(Nullable<Double> splitAmount) {
            if (splitAmount.isNull()) {
                this.splitAmount = null;
            } else if (splitAmount.isEmpty()) {
                this.splitAmount = Optional.empty();
            } else {
                this.splitAmount = Optional.of(splitAmount.get());
            }
            return this;
        }

        /**
         * <p>Service fees are any pass-through fees charged to the customer at the time of payment.  These aren't transferred to the merchant when the batch is transferred and funded.</p>
         */
        @JsonSetter(value = "serviceFees", nulls = Nulls.SKIP)
        public Builder serviceFees(Optional<Double> serviceFees) {
            this.serviceFees = serviceFees;
            return this;
        }

        public Builder serviceFees(Double serviceFees) {
            this.serviceFees = Optional.ofNullable(serviceFees);
            return this;
        }

        public Builder serviceFees(Nullable<Double> serviceFees) {
            if (serviceFees.isNull()) {
                this.serviceFees = null;
            } else if (serviceFees.isEmpty()) {
                this.serviceFees = Optional.empty();
            } else {
                this.serviceFees = Optional.of(serviceFees.get());
            }
            return this;
        }

        /**
         * <p>The net batch amount is the gross batch amount minus any returns, refunds,
         * billing and fees items, chargebacks, adjustments, and third party payments.</p>
         */
        @JsonSetter(value = "netBatchAmount", nulls = Nulls.SKIP)
        public Builder netBatchAmount(Optional<Double> netBatchAmount) {
            this.netBatchAmount = netBatchAmount;
            return this;
        }

        public Builder netBatchAmount(Double netBatchAmount) {
            this.netBatchAmount = Optional.ofNullable(netBatchAmount);
            return this;
        }

        public Builder netBatchAmount(Nullable<Double> netBatchAmount) {
            if (netBatchAmount.isNull()) {
                this.netBatchAmount = null;
            } else if (netBatchAmount.isEmpty()) {
                this.netBatchAmount = Optional.empty();
            } else {
                this.netBatchAmount = Optional.of(netBatchAmount.get());
            }
            return this;
        }

        /**
         * <p>The transfer amount is the net batch amount plus or minus any returns, refunds,  billing and fees items, chargebacks, adjustments, and third party payments.  This is the amount from the batch that is transferred to the merchant bank account.</p>
         */
        @JsonSetter(value = "transferAmount", nulls = Nulls.SKIP)
        public Builder transferAmount(Optional<Double> transferAmount) {
            this.transferAmount = transferAmount;
            return this;
        }

        public Builder transferAmount(Double transferAmount) {
            this.transferAmount = Optional.ofNullable(transferAmount);
            return this;
        }

        public Builder transferAmount(Nullable<Double> transferAmount) {
            if (transferAmount.isNull()) {
                this.transferAmount = null;
            } else if (transferAmount.isEmpty()) {
                this.transferAmount = Optional.empty();
            } else {
                this.transferAmount = Optional.of(transferAmount.get());
            }
            return this;
        }

        /**
         * <p>Refunds deducted from batch.</p>
         */
        @JsonSetter(value = "refunds", nulls = Nulls.SKIP)
        public Builder refunds(Optional<Double> refunds) {
            this.refunds = refunds;
            return this;
        }

        public Builder refunds(Double refunds) {
            this.refunds = Optional.ofNullable(refunds);
            return this;
        }

        public Builder refunds(Nullable<Double> refunds) {
            if (refunds.isNull()) {
                this.refunds = null;
            } else if (refunds.isEmpty()) {
                this.refunds = Optional.empty();
            } else {
                this.refunds = Optional.of(refunds.get());
            }
            return this;
        }

        /**
         * <p>Funds being held for fraud or risk concerns.</p>
         */
        @JsonSetter(value = "heldAmount", nulls = Nulls.SKIP)
        public Builder heldAmount(Optional<Double> heldAmount) {
            this.heldAmount = heldAmount;
            return this;
        }

        public Builder heldAmount(Double heldAmount) {
            this.heldAmount = Optional.ofNullable(heldAmount);
            return this;
        }

        public Builder heldAmount(Nullable<Double> heldAmount) {
            if (heldAmount.isNull()) {
                this.heldAmount = null;
            } else if (heldAmount.isEmpty()) {
                this.heldAmount = Optional.empty();
            } else {
                this.heldAmount = Optional.of(heldAmount.get());
            }
            return this;
        }

        /**
         * <p>Number of records in the response.</p>
         */
        @JsonSetter(value = "totalRecords", nulls = Nulls.SKIP)
        public Builder totalRecords(Optional<Integer> totalRecords) {
            this.totalRecords = totalRecords;
            return this;
        }

        public Builder totalRecords(Integer totalRecords) {
            this.totalRecords = Optional.ofNullable(totalRecords);
            return this;
        }

        public Builder totalRecords(Nullable<Integer> totalRecords) {
            if (totalRecords.isNull()) {
                this.totalRecords = null;
            } else if (totalRecords.isEmpty()) {
                this.totalRecords = Optional.empty();
            } else {
                this.totalRecords = Optional.of(totalRecords.get());
            }
            return this;
        }

        /**
         * <p>The total sum of the transfers in the response.</p>
         */
        @JsonSetter(value = "totalAmount", nulls = Nulls.SKIP)
        public Builder totalAmount(Optional<Double> totalAmount) {
            this.totalAmount = totalAmount;
            return this;
        }

        public Builder totalAmount(Double totalAmount) {
            this.totalAmount = Optional.ofNullable(totalAmount);
            return this;
        }

        public Builder totalAmount(Nullable<Double> totalAmount) {
            if (totalAmount.isNull()) {
                this.totalAmount = null;
            } else if (totalAmount.isEmpty()) {
                this.totalAmount = Optional.empty();
            } else {
                this.totalAmount = Optional.of(totalAmount.get());
            }
            return this;
        }

        /**
         * <p>The total sum of the transfers in the response.</p>
         */
        @JsonSetter(value = "totalNetAmount", nulls = Nulls.SKIP)
        public Builder totalNetAmount(Optional<Double> totalNetAmount) {
            this.totalNetAmount = totalNetAmount;
            return this;
        }

        public Builder totalNetAmount(Double totalNetAmount) {
            this.totalNetAmount = Optional.ofNullable(totalNetAmount);
            return this;
        }

        public Builder totalNetAmount(Nullable<Double> totalNetAmount) {
            if (totalNetAmount.isNull()) {
                this.totalNetAmount = null;
            } else if (totalNetAmount.isEmpty()) {
                this.totalNetAmount = Optional.empty();
            } else {
                this.totalNetAmount = Optional.of(totalNetAmount.get());
            }
            return this;
        }

        /**
         * <p>Number of pages in the response.</p>
         */
        @JsonSetter(value = "totalPages", nulls = Nulls.SKIP)
        public Builder totalPages(Optional<Integer> totalPages) {
            this.totalPages = totalPages;
            return this;
        }

        public Builder totalPages(Integer totalPages) {
            this.totalPages = Optional.ofNullable(totalPages);
            return this;
        }

        public Builder totalPages(Nullable<Integer> totalPages) {
            if (totalPages.isNull()) {
                this.totalPages = null;
            } else if (totalPages.isEmpty()) {
                this.totalPages = Optional.empty();
            } else {
                this.totalPages = Optional.of(totalPages.get());
            }
            return this;
        }

        /**
         * <p>Number of records per page.</p>
         */
        @JsonSetter(value = "pageSize", nulls = Nulls.SKIP)
        public Builder pageSize(Optional<Integer> pageSize) {
            this.pageSize = pageSize;
            return this;
        }

        public Builder pageSize(Integer pageSize) {
            this.pageSize = Optional.ofNullable(pageSize);
            return this;
        }

        public Builder pageSize(Nullable<Integer> pageSize) {
            if (pageSize.isNull()) {
                this.pageSize = null;
            } else if (pageSize.isEmpty()) {
                this.pageSize = Optional.empty();
            } else {
                this.pageSize = Optional.of(pageSize.get());
            }
            return this;
        }

        /**
         * <p>Auxiliary validation used internally by payment pages and components.</p>
         */
        @JsonSetter(value = "pageidentifier", nulls = Nulls.SKIP)
        public Builder pageidentifier(Optional<String> pageidentifier) {
            this.pageidentifier = pageidentifier;
            return this;
        }

        public Builder pageidentifier(String pageidentifier) {
            this.pageidentifier = Optional.ofNullable(pageidentifier);
            return this;
        }

        public Builder pageidentifier(Nullable<String> pageidentifier) {
            if (pageidentifier.isNull()) {
                this.pageidentifier = null;
            } else if (pageidentifier.isEmpty()) {
                this.pageidentifier = Optional.empty();
            } else {
                this.pageidentifier = Optional.of(pageidentifier.get());
            }
            return this;
        }

        public QueryTransferSummary build() {
            return new QueryTransferSummary(
                    achReturns,
                    adjustments,
                    billingFees,
                    chargebacks,
                    grossTransferAmount,
                    releaseAmount,
                    thirdPartyPaid,
                    totalNetAmountTransfer,
                    splitAmount,
                    serviceFees,
                    netBatchAmount,
                    transferAmount,
                    refunds,
                    heldAmount,
                    totalRecords,
                    totalAmount,
                    totalNetAmount,
                    totalPages,
                    pageSize,
                    pageidentifier,
                    additionalProperties);
        }
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.payabli.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.payabli.api.core.ObjectMappers;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = SubscriptionQueryRecords.Builder.class)
public final class SubscriptionQueryRecords {
    private final Optional<OffsetDateTime> createdAt;

    private final Optional<QueryTransactionPayorData> customer;

    private final Optional<OffsetDateTime> endDate;

    private final Optional<Long> entrypageId;

    private final Optional<String> externalPaypointId;

    private final Optional<Double> feeAmount;

    private final Optional<String> frequency;

    private final Optional<Long> idSub;

    private final Optional<BillData> invoiceData;

    private final Optional<OffsetDateTime> lastRun;

    private final Optional<OffsetDateTime> lastUpdated;

    private final Optional<Integer> leftCycles;

    private final Optional<String> method;

    private final Optional<Double> netAmount;

    private final Optional<OffsetDateTime> nextDate;

    private final Optional<String> parentOrgName;

    private final Optional<QueryPaymentData> paymentData;

    private final Optional<String> paypointDbaname;

    private final Optional<String> paypointEntryname;

    private final Optional<Long> paypointId;

    private final Optional<String> paypointLegalname;

    private final Optional<Integer> planId;

    private final Optional<String> source;

    private final Optional<OffsetDateTime> startDate;

    private final Optional<List<GeneralEvents>> subEvents;

    private final Optional<Integer> subStatus;

    private final Optional<Double> totalAmount;

    private final Optional<Integer> totalCycles;

    private final Optional<Boolean> untilCancelled;

    private final Map<String, Object> additionalProperties;

    private SubscriptionQueryRecords(
            Optional<OffsetDateTime> createdAt,
            Optional<QueryTransactionPayorData> customer,
            Optional<OffsetDateTime> endDate,
            Optional<Long> entrypageId,
            Optional<String> externalPaypointId,
            Optional<Double> feeAmount,
            Optional<String> frequency,
            Optional<Long> idSub,
            Optional<BillData> invoiceData,
            Optional<OffsetDateTime> lastRun,
            Optional<OffsetDateTime> lastUpdated,
            Optional<Integer> leftCycles,
            Optional<String> method,
            Optional<Double> netAmount,
            Optional<OffsetDateTime> nextDate,
            Optional<String> parentOrgName,
            Optional<QueryPaymentData> paymentData,
            Optional<String> paypointDbaname,
            Optional<String> paypointEntryname,
            Optional<Long> paypointId,
            Optional<String> paypointLegalname,
            Optional<Integer> planId,
            Optional<String> source,
            Optional<OffsetDateTime> startDate,
            Optional<List<GeneralEvents>> subEvents,
            Optional<Integer> subStatus,
            Optional<Double> totalAmount,
            Optional<Integer> totalCycles,
            Optional<Boolean> untilCancelled,
            Map<String, Object> additionalProperties) {
        this.createdAt = createdAt;
        this.customer = customer;
        this.endDate = endDate;
        this.entrypageId = entrypageId;
        this.externalPaypointId = externalPaypointId;
        this.feeAmount = feeAmount;
        this.frequency = frequency;
        this.idSub = idSub;
        this.invoiceData = invoiceData;
        this.lastRun = lastRun;
        this.lastUpdated = lastUpdated;
        this.leftCycles = leftCycles;
        this.method = method;
        this.netAmount = netAmount;
        this.nextDate = nextDate;
        this.parentOrgName = parentOrgName;
        this.paymentData = paymentData;
        this.paypointDbaname = paypointDbaname;
        this.paypointEntryname = paypointEntryname;
        this.paypointId = paypointId;
        this.paypointLegalname = paypointLegalname;
        this.planId = planId;
        this.source = source;
        this.startDate = startDate;
        this.subEvents = subEvents;
        this.subStatus = subStatus;
        this.totalAmount = totalAmount;
        this.totalCycles = totalCycles;
        this.untilCancelled = untilCancelled;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Timestamp of when the subscription ws created, in UTC.
     */
    @JsonProperty("CreatedAt")
    public Optional<OffsetDateTime> getCreatedAt() {
        return createdAt;
    }

    @JsonProperty("Customer")
    public Optional<QueryTransactionPayorData> getCustomer() {
        return customer;
    }

    /**
     * @return The subscription's end date.
     */
    @JsonProperty("EndDate")
    public Optional<OffsetDateTime> getEndDate() {
        return endDate;
    }

    @JsonProperty("EntrypageId")
    public Optional<Long> getEntrypageId() {
        return entrypageId;
    }

    @JsonProperty("ExternalPaypointID")
    public Optional<String> getExternalPaypointId() {
        return externalPaypointId;
    }

    /**
     * @return Fee applied to the subscription.
     */
    @JsonProperty("FeeAmount")
    public Optional<Double> getFeeAmount() {
        return feeAmount;
    }

    /**
     * @return The subscription's frequency.
     */
    @JsonProperty("Frequency")
    public Optional<String> getFrequency() {
        return frequency;
    }

    /**
     * @return The subscription's ID.
     */
    @JsonProperty("IdSub")
    public Optional<Long> getIdSub() {
        return idSub;
    }

    @JsonProperty("InvoiceData")
    public Optional<BillData> getInvoiceData() {
        return invoiceData;
    }

    /**
     * @return The last time the subscription was processed.
     */
    @JsonProperty("LastRun")
    public Optional<OffsetDateTime> getLastRun() {
        return lastRun;
    }

    /**
     * @return The last date and time the subscription was updated.
     */
    @JsonProperty("LastUpdated")
    public Optional<OffsetDateTime> getLastUpdated() {
        return lastUpdated;
    }

    /**
     * @return The number of cycles the subscription has left.
     */
    @JsonProperty("LeftCycles")
    public Optional<Integer> getLeftCycles() {
        return leftCycles;
    }

    /**
     * @return The subscription's payment method.
     */
    @JsonProperty("Method")
    public Optional<String> getMethod() {
        return method;
    }

    /**
     * @return The subscription amount, minus any fees.
     */
    @JsonProperty("NetAmount")
    public Optional<Double> getNetAmount() {
        return netAmount;
    }

    /**
     * @return The next date the subscription will be processed.
     */
    @JsonProperty("NextDate")
    public Optional<OffsetDateTime> getNextDate() {
        return nextDate;
    }

    @JsonProperty("ParentOrgName")
    public Optional<String> getParentOrgName() {
        return parentOrgName;
    }

    @JsonProperty("PaymentData")
    public Optional<QueryPaymentData> getPaymentData() {
        return paymentData;
    }

    /**
     * @return The paypoint's DBA name.
     */
    @JsonProperty("PaypointDbaname")
    public Optional<String> getPaypointDbaname() {
        return paypointDbaname;
    }

    /**
     * @return The paypoint's entryname.
     */
    @JsonProperty("PaypointEntryname")
    public Optional<String> getPaypointEntryname() {
        return paypointEntryname;
    }

    @JsonProperty("PaypointId")
    public Optional<Long> getPaypointId() {
        return paypointId;
    }

    /**
     * @return The paypoint's legal name.
     */
    @JsonProperty("PaypointLegalname")
    public Optional<String> getPaypointLegalname() {
        return paypointLegalname;
    }

    /**
     * @return Payment plan ID.
     */
    @JsonProperty("PlanId")
    public Optional<Integer> getPlanId() {
        return planId;
    }

    @JsonProperty("Source")
    public Optional<String> getSource() {
        return source;
    }

    /**
     * @return The subscription start date.
     */
    @JsonProperty("StartDate")
    public Optional<OffsetDateTime> getStartDate() {
        return startDate;
    }

    /**
     * @return Events associated with the subscription.
     */
    @JsonProperty("SubEvents")
    public Optional<List<GeneralEvents>> getSubEvents() {
        return subEvents;
    }

    /**
     * @return The subscription's status.
     * <ul>
     * <li>0: Paused</li>
     * <li>1: Active</li>
     * </ul>
     */
    @JsonProperty("SubStatus")
    public Optional<Integer> getSubStatus() {
        return subStatus;
    }

    /**
     * @return The subscription amount, including any fees.
     */
    @JsonProperty("TotalAmount")
    public Optional<Double> getTotalAmount() {
        return totalAmount;
    }

    /**
     * @return The total number of cycles the subscription is set to run.
     */
    @JsonProperty("TotalCycles")
    public Optional<Integer> getTotalCycles() {
        return totalCycles;
    }

    /**
     * @return When <code>true</code>, the subscription has no explicit end date and will run until canceled.
     */
    @JsonProperty("UntilCancelled")
    public Optional<Boolean> getUntilCancelled() {
        return untilCancelled;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof SubscriptionQueryRecords && equalTo((SubscriptionQueryRecords) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(SubscriptionQueryRecords other) {
        return createdAt.equals(other.createdAt)
                && customer.equals(other.customer)
                && endDate.equals(other.endDate)
                && entrypageId.equals(other.entrypageId)
                && externalPaypointId.equals(other.externalPaypointId)
                && feeAmount.equals(other.feeAmount)
                && frequency.equals(other.frequency)
                && idSub.equals(other.idSub)
                && invoiceData.equals(other.invoiceData)
                && lastRun.equals(other.lastRun)
                && lastUpdated.equals(other.lastUpdated)
                && leftCycles.equals(other.leftCycles)
                && method.equals(other.method)
                && netAmount.equals(other.netAmount)
                && nextDate.equals(other.nextDate)
                && parentOrgName.equals(other.parentOrgName)
                && paymentData.equals(other.paymentData)
                && paypointDbaname.equals(other.paypointDbaname)
                && paypointEntryname.equals(other.paypointEntryname)
                && paypointId.equals(other.paypointId)
                && paypointLegalname.equals(other.paypointLegalname)
                && planId.equals(other.planId)
                && source.equals(other.source)
                && startDate.equals(other.startDate)
                && subEvents.equals(other.subEvents)
                && subStatus.equals(other.subStatus)
                && totalAmount.equals(other.totalAmount)
                && totalCycles.equals(other.totalCycles)
                && untilCancelled.equals(other.untilCancelled);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.createdAt,
                this.customer,
                this.endDate,
                this.entrypageId,
                this.externalPaypointId,
                this.feeAmount,
                this.frequency,
                this.idSub,
                this.invoiceData,
                this.lastRun,
                this.lastUpdated,
                this.leftCycles,
                this.method,
                this.netAmount,
                this.nextDate,
                this.parentOrgName,
                this.paymentData,
                this.paypointDbaname,
                this.paypointEntryname,
                this.paypointId,
                this.paypointLegalname,
                this.planId,
                this.source,
                this.startDate,
                this.subEvents,
                this.subStatus,
                this.totalAmount,
                this.totalCycles,
                this.untilCancelled);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<OffsetDateTime> createdAt = Optional.empty();

        private Optional<QueryTransactionPayorData> customer = Optional.empty();

        private Optional<OffsetDateTime> endDate = Optional.empty();

        private Optional<Long> entrypageId = Optional.empty();

        private Optional<String> externalPaypointId = Optional.empty();

        private Optional<Double> feeAmount = Optional.empty();

        private Optional<String> frequency = Optional.empty();

        private Optional<Long> idSub = Optional.empty();

        private Optional<BillData> invoiceData = Optional.empty();

        private Optional<OffsetDateTime> lastRun = Optional.empty();

        private Optional<OffsetDateTime> lastUpdated = Optional.empty();

        private Optional<Integer> leftCycles = Optional.empty();

        private Optional<String> method = Optional.empty();

        private Optional<Double> netAmount = Optional.empty();

        private Optional<OffsetDateTime> nextDate = Optional.empty();

        private Optional<String> parentOrgName = Optional.empty();

        private Optional<QueryPaymentData> paymentData = Optional.empty();

        private Optional<String> paypointDbaname = Optional.empty();

        private Optional<String> paypointEntryname = Optional.empty();

        private Optional<Long> paypointId = Optional.empty();

        private Optional<String> paypointLegalname = Optional.empty();

        private Optional<Integer> planId = Optional.empty();

        private Optional<String> source = Optional.empty();

        private Optional<OffsetDateTime> startDate = Optional.empty();

        private Optional<List<GeneralEvents>> subEvents = Optional.empty();

        private Optional<Integer> subStatus = Optional.empty();

        private Optional<Double> totalAmount = Optional.empty();

        private Optional<Integer> totalCycles = Optional.empty();

        private Optional<Boolean> untilCancelled = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(SubscriptionQueryRecords other) {
            createdAt(other.getCreatedAt());
            customer(other.getCustomer());
            endDate(other.getEndDate());
            entrypageId(other.getEntrypageId());
            externalPaypointId(other.getExternalPaypointId());
            feeAmount(other.getFeeAmount());
            frequency(other.getFrequency());
            idSub(other.getIdSub());
            invoiceData(other.getInvoiceData());
            lastRun(other.getLastRun());
            lastUpdated(other.getLastUpdated());
            leftCycles(other.getLeftCycles());
            method(other.getMethod());
            netAmount(other.getNetAmount());
            nextDate(other.getNextDate());
            parentOrgName(other.getParentOrgName());
            paymentData(other.getPaymentData());
            paypointDbaname(other.getPaypointDbaname());
            paypointEntryname(other.getPaypointEntryname());
            paypointId(other.getPaypointId());
            paypointLegalname(other.getPaypointLegalname());
            planId(other.getPlanId());
            source(other.getSource());
            startDate(other.getStartDate());
            subEvents(other.getSubEvents());
            subStatus(other.getSubStatus());
            totalAmount(other.getTotalAmount());
            totalCycles(other.getTotalCycles());
            untilCancelled(other.getUntilCancelled());
            return this;
        }

        /**
         * <p>Timestamp of when the subscription ws created, in UTC.</p>
         */
        @JsonSetter(value = "CreatedAt", nulls = Nulls.SKIP)
        public Builder createdAt(Optional<OffsetDateTime> createdAt) {
            this.createdAt = createdAt;
            return this;
        }

        public Builder createdAt(OffsetDateTime createdAt) {
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        @JsonSetter(value = "Customer", nulls = Nulls.SKIP)
        public Builder customer(Optional<QueryTransactionPayorData> customer) {
            this.customer = customer;
            return this;
        }

        public Builder customer(QueryTransactionPayorData customer) {
            this.customer = Optional.ofNullable(customer);
            return this;
        }

        /**
         * <p>The subscription's end date.</p>
         */
        @JsonSetter(value = "EndDate", nulls = Nulls.SKIP)
        public Builder endDate(Optional<OffsetDateTime> endDate) {
            this.endDate = endDate;
            return this;
        }

        public Builder endDate(OffsetDateTime endDate) {
            this.endDate = Optional.ofNullable(endDate);
            return this;
        }

        @JsonSetter(value = "EntrypageId", nulls = Nulls.SKIP)
        public Builder entrypageId(Optional<Long> entrypageId) {
            this.entrypageId = entrypageId;
            return this;
        }

        public Builder entrypageId(Long entrypageId) {
            this.entrypageId = Optional.ofNullable(entrypageId);
            return this;
        }

        @JsonSetter(value = "ExternalPaypointID", nulls = Nulls.SKIP)
        public Builder externalPaypointId(Optional<String> externalPaypointId) {
            this.externalPaypointId = externalPaypointId;
            return this;
        }

        public Builder externalPaypointId(String externalPaypointId) {
            this.externalPaypointId = Optional.ofNullable(externalPaypointId);
            return this;
        }

        /**
         * <p>Fee applied to the subscription.</p>
         */
        @JsonSetter(value = "FeeAmount", nulls = Nulls.SKIP)
        public Builder feeAmount(Optional<Double> feeAmount) {
            this.feeAmount = feeAmount;
            return this;
        }

        public Builder feeAmount(Double feeAmount) {
            this.feeAmount = Optional.ofNullable(feeAmount);
            return this;
        }

        /**
         * <p>The subscription's frequency.</p>
         */
        @JsonSetter(value = "Frequency", nulls = Nulls.SKIP)
        public Builder frequency(Optional<String> frequency) {
            this.frequency = frequency;
            return this;
        }

        public Builder frequency(String frequency) {
            this.frequency = Optional.ofNullable(frequency);
            return this;
        }

        /**
         * <p>The subscription's ID.</p>
         */
        @JsonSetter(value = "IdSub", nulls = Nulls.SKIP)
        public Builder idSub(Optional<Long> idSub) {
            this.idSub = idSub;
            return this;
        }

        public Builder idSub(Long idSub) {
            this.idSub = Optional.ofNullable(idSub);
            return this;
        }

        @JsonSetter(value = "InvoiceData", nulls = Nulls.SKIP)
        public Builder invoiceData(Optional<BillData> invoiceData) {
            this.invoiceData = invoiceData;
            return this;
        }

        public Builder invoiceData(BillData invoiceData) {
            this.invoiceData = Optional.ofNullable(invoiceData);
            return this;
        }

        /**
         * <p>The last time the subscription was processed.</p>
         */
        @JsonSetter(value = "LastRun", nulls = Nulls.SKIP)
        public Builder lastRun(Optional<OffsetDateTime> lastRun) {
            this.lastRun = lastRun;
            return this;
        }

        public Builder lastRun(OffsetDateTime lastRun) {
            this.lastRun = Optional.ofNullable(lastRun);
            return this;
        }

        /**
         * <p>The last date and time the subscription was updated.</p>
         */
        @JsonSetter(value = "LastUpdated", nulls = Nulls.SKIP)
        public Builder lastUpdated(Optional<OffsetDateTime> lastUpdated) {
            this.lastUpdated = lastUpdated;
            return this;
        }

        public Builder lastUpdated(OffsetDateTime lastUpdated) {
            this.lastUpdated = Optional.ofNullable(lastUpdated);
            return this;
        }

        /**
         * <p>The number of cycles the subscription has left.</p>
         */
        @JsonSetter(value = "LeftCycles", nulls = Nulls.SKIP)
        public Builder leftCycles(Optional<Integer> leftCycles) {
            this.leftCycles = leftCycles;
            return this;
        }

        public Builder leftCycles(Integer leftCycles) {
            this.leftCycles = Optional.ofNullable(leftCycles);
            return this;
        }

        /**
         * <p>The subscription's payment method.</p>
         */
        @JsonSetter(value = "Method", nulls = Nulls.SKIP)
        public Builder method(Optional<String> method) {
            this.method = method;
            return this;
        }

        public Builder method(String method) {
            this.method = Optional.ofNullable(method);
            return this;
        }

        /**
         * <p>The subscription amount, minus any fees.</p>
         */
        @JsonSetter(value = "NetAmount", nulls = Nulls.SKIP)
        public Builder netAmount(Optional<Double> netAmount) {
            this.netAmount = netAmount;
            return this;
        }

        public Builder netAmount(Double netAmount) {
            this.netAmount = Optional.ofNullable(netAmount);
            return this;
        }

        /**
         * <p>The next date the subscription will be processed.</p>
         */
        @JsonSetter(value = "NextDate", nulls = Nulls.SKIP)
        public Builder nextDate(Optional<OffsetDateTime> nextDate) {
            this.nextDate = nextDate;
            return this;
        }

        public Builder nextDate(OffsetDateTime nextDate) {
            this.nextDate = Optional.ofNullable(nextDate);
            return this;
        }

        @JsonSetter(value = "ParentOrgName", nulls = Nulls.SKIP)
        public Builder parentOrgName(Optional<String> parentOrgName) {
            this.parentOrgName = parentOrgName;
            return this;
        }

        public Builder parentOrgName(String parentOrgName) {
            this.parentOrgName = Optional.ofNullable(parentOrgName);
            return this;
        }

        @JsonSetter(value = "PaymentData", nulls = Nulls.SKIP)
        public Builder paymentData(Optional<QueryPaymentData> paymentData) {
            this.paymentData = paymentData;
            return this;
        }

        public Builder paymentData(QueryPaymentData paymentData) {
            this.paymentData = Optional.ofNullable(paymentData);
            return this;
        }

        /**
         * <p>The paypoint's DBA name.</p>
         */
        @JsonSetter(value = "PaypointDbaname", nulls = Nulls.SKIP)
        public Builder paypointDbaname(Optional<String> paypointDbaname) {
            this.paypointDbaname = paypointDbaname;
            return this;
        }

        public Builder paypointDbaname(String paypointDbaname) {
            this.paypointDbaname = Optional.ofNullable(paypointDbaname);
            return this;
        }

        /**
         * <p>The paypoint's entryname.</p>
         */
        @JsonSetter(value = "PaypointEntryname", nulls = Nulls.SKIP)
        public Builder paypointEntryname(Optional<String> paypointEntryname) {
            this.paypointEntryname = paypointEntryname;
            return this;
        }

        public Builder paypointEntryname(String paypointEntryname) {
            this.paypointEntryname = Optional.ofNullable(paypointEntryname);
            return this;
        }

        @JsonSetter(value = "PaypointId", nulls = Nulls.SKIP)
        public Builder paypointId(Optional<Long> paypointId) {
            this.paypointId = paypointId;
            return this;
        }

        public Builder paypointId(Long paypointId) {
            this.paypointId = Optional.ofNullable(paypointId);
            return this;
        }

        /**
         * <p>The paypoint's legal name.</p>
         */
        @JsonSetter(value = "PaypointLegalname", nulls = Nulls.SKIP)
        public Builder paypointLegalname(Optional<String> paypointLegalname) {
            this.paypointLegalname = paypointLegalname;
            return this;
        }

        public Builder paypointLegalname(String paypointLegalname) {
            this.paypointLegalname = Optional.ofNullable(paypointLegalname);
            return this;
        }

        /**
         * <p>Payment plan ID.</p>
         */
        @JsonSetter(value = "PlanId", nulls = Nulls.SKIP)
        public Builder planId(Optional<Integer> planId) {
            this.planId = planId;
            return this;
        }

        public Builder planId(Integer planId) {
            this.planId = Optional.ofNullable(planId);
            return this;
        }

        @JsonSetter(value = "Source", nulls = Nulls.SKIP)
        public Builder source(Optional<String> source) {
            this.source = source;
            return this;
        }

        public Builder source(String source) {
            this.source = Optional.ofNullable(source);
            return this;
        }

        /**
         * <p>The subscription start date.</p>
         */
        @JsonSetter(value = "StartDate", nulls = Nulls.SKIP)
        public Builder startDate(Optional<OffsetDateTime> startDate) {
            this.startDate = startDate;
            return this;
        }

        public Builder startDate(OffsetDateTime startDate) {
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * <p>Events associated with the subscription.</p>
         */
        @JsonSetter(value = "SubEvents", nulls = Nulls.SKIP)
        public Builder subEvents(Optional<List<GeneralEvents>> subEvents) {
            this.subEvents = subEvents;
            return this;
        }

        public Builder subEvents(List<GeneralEvents> subEvents) {
            this.subEvents = Optional.ofNullable(subEvents);
            return this;
        }

        /**
         * <p>The subscription's status.</p>
         * <ul>
         * <li>0: Paused</li>
         * <li>1: Active</li>
         * </ul>
         */
        @JsonSetter(value = "SubStatus", nulls = Nulls.SKIP)
        public Builder subStatus(Optional<Integer> subStatus) {
            this.subStatus = subStatus;
            return this;
        }

        public Builder subStatus(Integer subStatus) {
            this.subStatus = Optional.ofNullable(subStatus);
            return this;
        }

        /**
         * <p>The subscription amount, including any fees.</p>
         */
        @JsonSetter(value = "TotalAmount", nulls = Nulls.SKIP)
        public Builder totalAmount(Optional<Double> totalAmount) {
            this.totalAmount = totalAmount;
            return this;
        }

        public Builder totalAmount(Double totalAmount) {
            this.totalAmount = Optional.ofNullable(totalAmount);
            return this;
        }

        /**
         * <p>The total number of cycles the subscription is set to run.</p>
         */
        @JsonSetter(value = "TotalCycles", nulls = Nulls.SKIP)
        public Builder totalCycles(Optional<Integer> totalCycles) {
            this.totalCycles = totalCycles;
            return this;
        }

        public Builder totalCycles(Integer totalCycles) {
            this.totalCycles = Optional.ofNullable(totalCycles);
            return this;
        }

        /**
         * <p>When <code>true</code>, the subscription has no explicit end date and will run until canceled.</p>
         */
        @JsonSetter(value = "UntilCancelled", nulls = Nulls.SKIP)
        public Builder untilCancelled(Optional<Boolean> untilCancelled) {
            this.untilCancelled = untilCancelled;
            return this;
        }

        public Builder untilCancelled(Boolean untilCancelled) {
            this.untilCancelled = Optional.ofNullable(untilCancelled);
            return this;
        }

        public SubscriptionQueryRecords build() {
            return new SubscriptionQueryRecords(
                    createdAt,
                    customer,
                    endDate,
                    entrypageId,
                    externalPaypointId,
                    feeAmount,
                    frequency,
                    idSub,
                    invoiceData,
                    lastRun,
                    lastUpdated,
                    leftCycles,
                    method,
                    netAmount,
                    nextDate,
                    parentOrgName,
                    paymentData,
                    paypointDbaname,
                    paypointEntryname,
                    paypointId,
                    paypointLegalname,
                    planId,
                    source,
                    startDate,
                    subEvents,
                    subStatus,
                    totalAmount,
                    totalCycles,
                    untilCancelled,
                    additionalProperties);
        }
    }
}
